const AppError = require('../utils/appError');

const handleCastDBError = (error) => {
  const message = `Invalid ${error.path}: ${error.value}`;

  return new AppError(message, 400);
};

const handleDuplicateFieldsDBError = (error) => {
  const regex = /name: "(.*?)"/;
  const match = error?.message.match(regex);

  const message = `Duplicated field value ${match[0]}`;

  return new AppError(message, 400);
};

const handleValidationFieldsDBError = (error) => {
  //FIRST OPTION
  // const errors = error.errors;

  // let errorStr = '';

  // Object.keys(errors).forEach(errorKey => {
  //     errorStr = errorStr + `${errors[errorKey].message}. `
  // });
  //with this option, we let a final blank space at the end of message

  //SECOND OPTION
  const errors = Object.values(error.errors).map((err) => err.message);

  const message = `Invalid data: ${errors.join('. ')}`;

  return new AppError(message, 400);
};

const handleJsonWebTokenError = () => new AppError('Invalid token', 401);

const handleJsonWebTokenExpiredError = () =>
  new AppError('Token has expired, please log in again', 401);

const sendDevelopmentError = (error, req, res) => {
  if (req.originalUrl.startsWith('/api')) {
    //TODO: DELETE, IT'S FOR PUG
    return res.status(error.statusCode).json({
      status: error.status,
      stack: error.stack,
      message: error.message,
      error: error,
    });
  }
  //TODO: DELETE, IT'S FOR PUG
  return res.status(error.statusCode).render('error', {
    title: 'Something went wrong',
    msg: error.message,
  });
};

/**
 * Sends a production error response to the client.
 *
 * @param {Error} error - The error object.
 * @param {Response} res - The response object.
 * @return {void}
 */
const sendProductionError = (error, req, res) => {
  //API
  if (req.originalUrl.startsWith('/api')) {
    //TODO: DELETE ELSE, IT'S FOR PUG
    //if we have an operational error we have to
    //let the user know about what happended
    if (error.isOperational) {
      //we trust the error.message is not something weird,
      //it's a message generated by us
      return res.status(error.code).json({
        status: error.status,
        message: error.message,
      });
    }

    //if we have a programming error, we don't want
    //the user to know about the details of the error
    if (!error.isOperational) {
      return res.status(error.code).json({
        status: 'error',
        message: 'Something went wrong',
      });
    }
  }
  //TODO: DELETE, IT'S FOR PUG
  //RENDERED WEBSITE
  return res.status(error.statusCode).render('error', {
    title: 'PLease try again later',
    msg: error.message,
  });
};

const errorHandler = (error, req, res, next) => {
  error.statusCode = error.statusCode || 500;
  error.code = error.code || 500;
  error.status = error.status || 'error';

  if (process.env.NODE_ENV === 'development') {
    return sendDevelopmentError(error, req, res);
  }

  if (process.env.NODE_ENV === 'production') {
    let prodError = { ...error };

    //Cast Error: the name that we receive from mongoose
    //when you hit an invalid id in the endpoint for example:
    //GET: api/v1/tours/uuuuu

    //if(prodError.name === 'CastError'){ prodError doesnt have .name property
    // see this https://stackoverflow.com/questions/63971976/spread-operator-does-not-seem-to-copy-full-object

    if (error.name === 'CastError') {
      prodError = handleCastDBError(prodError);
    }

    if (error.code === 11000) {
      prodError = handleDuplicateFieldsDBError(error);
    }

    if (error.name === 'ValidationError') {
      prodError = handleValidationFieldsDBError(prodError);
    }

    if (error.name === 'JsonWebTokenError') {
      prodError = handleJsonWebTokenError();
    }

    if (error.name === 'TokenExpiredError') {
      prodError = handleJsonWebTokenExpiredError();
    }

    return sendProductionError(prodError, req, res);
  }

  res.status(error.code).json({
    status: error.status,
    message: error.message,
  });
};

module.exports = errorHandler;
